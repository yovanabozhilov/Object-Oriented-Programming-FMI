**Задача:** Даден е двоичен файл, който е разделен на блокове – всеки с размер от 32 байта. Нашата задача е да намерим всички блокове, които участват във веригата и да построим съобщението, което ще се образува при конкатенация на всички малки съобщения от блоковете.
Един блок изглежда по следния начин: { [next – 2B] [textLength – 2B] [text – up to 28B] }.
- **Next (2 BYTES)** – кой е номерът на следващия блок
- **TextLength (2 BYTES)** – броят на символите, които участват в текста
- **Text (MAX 28 BYTES)** – символите, които образуват текста в блока
Всеки блок си има номер, започвайти от 0. Не знаем колко е броят на всички блокове. Числото, което стои в next указва кой е номерът на следващия блок от веригата. ВЪВ ВЕРИГАТА НЯМА да има цикли. Може да има блокови, които не участват във веригата, както и че може последователността да не е строго растяща. Винаги първият блок е този с номер 0, а последният е този, на който next-a е -1. Навсякъде да се работи с точен размер на паметта.


**Пример  
0 [4][3][C++…]  
1 [0][6][si-oop]  
2 [5][3][The….]  
3 [3][5][Test….]  
4 [2][2][Is….]  
5 [-1][8][Greatest…]  
6 [2][5][dummy…]**