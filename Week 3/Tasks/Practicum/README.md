## Задача 1:
Да се напише функция, която намира големината на файл.
## Задача 2 (Използвайте функцията от Зад 1):
Да се напишат програми, които запазват/четат масиви от обекти в двоичен файл, които не използват динамична памет. (Напишете примера със студента който съдържа име с максимална дължина 50 символа и години цяло число)



## Задача 3 (Използвайте функцията от Зад 1):
Да се напише програма, която намира, кои байтове не се срещат в двоичен файл.
## Задача 4:
Да се напише програма, която прочита масив от числа от един файл и за записва четните от тях в нов файл even.dat и нечетните в odd.dat.
- **`Да се напиште с допълнителна памет:`** – тоест да ги разделите в отделни масиви `int* evenArr` и `int* oddArr`.
- **`Да се напиште БЕЗ допълнителна памет:`** – тоест да нямате **масив**
- **Допълнително!!!**: да се добави и записване на простите числа в двоичен файл `prime.dat` използвайте един масив и **function pointer** за 3-те вида файла в една функция **(Вижте примера за CSV Parser)**


## Задача 5: 
Книга описваме чрез заглавието й(низ с максимален размер 128), година на издаване(цяло число) и цена(рационално число): 
- В тесктов файл са записани наличните книги в книжарницата на ООП-ландия в следния формат:
```
<книга> <година-на-издаване> <цена>
```
Пример:
```
Harry-Potter 1997 20
Solo-Leveling 2023 25
```
- Прочететe текствовия файл и го запишете в масив от книги
- От двоичен файл `year.dat` прочитате няколко години на издаване. Ако някоя от годините съвпада с година на издаване на някоя книга, то книгата се записва в двоичен файл `book.dat`

## Задача 6: 
Да се създаде структура `Product`, която се описва със следните характеристики:
- име на продукта (до 100 символа);
- количество в наличност (цяло число);
- цена на продукта (дробно число);
- категория на продукта - `ELECTRONICS`, `CLOTHING`, `BOOKS`, `FOOD` или `BEAUTY`;
- доставчик на продукта (до 100 символа);

Да се създаде програма, която управлява склад от продукти, като информацията се съхранява в двоичен файл. 
Нека програмата поддържа следните функционалности:
- Зареждане на продуктите от двоичен файл в паметта;
- По подаден двоичен файл да се вкарат n продукта, като информация за тях се чете от конзолата. Ако информацията, въведена за някой продукт, е валидна, и ако няма вече такова име на продукт във файла, продуктът се запазва в двоичния файл.
- Промяна на информацията за наличното количество от даден продукт и записване на новите данни във файла.
- Извеждане на информация за всички продукти от склада;
- Извеждане на информация за конкретен продукт по подадено име;
- По подадено име на друг файл и категория да се запишат всички продукти от дадената категория в съответния файл;


## Задача 7
Напишете структура ```Pokemon```, който се състои от:

- име (символен низ с най-много 50 символа)
- тип (изброим тип със следните възможности: NORMAL, FIRE, WATER, GRASS, ELECTRIC, GHOST, FLYING)
- сила (цяло положително число от 10 до 1000)

Напишете следните функции:
- функция създаваща покемон от стандартния вход
- функция създаваща покемон от двоичен поток
- функция записваща покемон в двоичен поток

Създайте структура ```PokemonHandler```, който да се грижи за ```наредена по сила``` колекция от покемони. 

**Тази структура НЕ пази никакви покемони в себе си! Тя работи само с предоставения двоичен файл.**

**`Disclaimer:` Може да приемате във функциите директно fstream& И да работите с него, Идеята е да не пазите в програмата масив от покемони а да работите изцяло със файла като масив**

Напишете следните функции:
- ```c++
  PokemonHandler newPokemonHandler(const char* filename)
  ```
  тази функция създава ```PokemonHandler``` от двоичен файл
- ```c++
  int size(const PokemonHandler &ph)
  //OR
  int size(std::fstream& file)
  ```
  връща размера на колекцията от покемони
- ```c++
  Pokemon at(const PokemonHandler &ph, int i)
  //OR
  Pokemon at(std::fstream& file, int i)
  ```
  връщаща покемонът намиращ се на ```i-ти``` индекс (погрижете се дали тази индекс е валиден)
- ```c++
  void swap(const PokemonHandler &ph, int i, int j)
  //OR
  void swap(std::fstream& file, int i, int j)
  ```
  разменя покемоните на индекси ```i``` и ```j``` (валидирайте коректността на индексите). Идеята е да я ползвате като помощна функция
- ```c++
  void insert(const PokemonHandler &ph, const Pokemon &pokemon)
  //OR
  void insert(std::fstream& file, const Pokemon &pokemon)
  ```
  добавя покемон в наредената ни колекция
- ```c++
  void textify(const PokemonHandler &ph, const char* filename)
  //OR
  void textify(std::fstream& file, const char* filename)
  ```
  записва цялата колекция в текстов файл с име ```filename```
- ```c++
  void untextify(PokemonHandler &ph, const char* filename)
  //OR
  void untextify(std::fstream& file, const char* filename)
  ```
  зарежда колекция от текстов файл ```filename```. Очаква се да се изтрие всичко, което сме имали до сега в ```PokemonHandler```

Демонстрирайте в ```main()``` как работи програмата ви, тоест всички функции от ```PokemonHandler``` е достатъчно понеже те включват в себе си ```Pokemon```. Изборът е ваш за формата на текстовия файл използван от ```textify``` и ```untextify```, той трябва да ви е удобен за лесно четене и писане. За демонстрацията вероятно ще използвате често функцията на ```Pokemon``` за четене от стандартния вход на покемон.

**Замислете се как ще разбирате колко елемента има в един двоичен файл с покемони, понеже ```PokemonHandler``` знае единствено името на файла или потока**

## БОНУС:
След като Христо успешно завърши първи курс на ФМИ, той беше готов да започне работа. Но понеже работодателите, търсещи неговите невероятни умения, бяха повече от очакваното, той реши да изтрие имейла си и да направи собствена система, чрез която да получава покани за работа.

Създайте структура, описваща обява за работа. Структурата трябва да съдържа:

    1) Име на фирмата. То трябва да е с максимална дължина от 25 символа.
    2) Брой на програмистите, с които той ще работи в екип.
    3) Брой на дните платен отпуск през годината.
    4) Сума, която ще му бъде изплатена след успешно завършване на проекта  (от тип long long)

Създайте функция, която прочита n на брой заявки от стандартния вход.
Заявките се запазват в двоичен файл, като ако във файла вече има информация,тя не се изтрива.

Създайте функция void filterOffers(const char* filePath, long long minSalary), която приема адрес на файл, от който четем заявките. Извежда на стандартния изход всички обяви за работа, които предлагат поне толкова пари, колкото са подадени като аргумент.

Създайте функция, bool existOffer(const char* filePath, const char* name),
която проверява дали дадена фирма е пратила покана за работа.

Бонус №1: Създайте void perfectOffer(const char* filePath, int maxCoworkers, int minVacancyDays, int minSalary), която извежда във файл всички обяви, които отговарят точно на изискванията на Христо.

Бонус №2: Създайте система, която работи чрез следните заявки:

    a <оферта> - добавя оферта за работа

    i - показва всички оферти

    s <име на фирма> - връща дали фирмата съществува

    f <число> - извежда всички обяви, за които заплатата е по - висока от числото
    q - изход от системата